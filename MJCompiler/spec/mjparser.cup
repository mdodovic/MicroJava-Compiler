
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;

import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	boolean errorDetected;
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
		errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with{:
	errorDetected = false;

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* terminals */

terminal PROG; /* "program" */ 
terminal CONST; /* "const" */
terminal VOID; /* "void" */

terminal CLASS; /* "class" */
terminal EXTENDS; /* "extends" */

terminal SEMI; /* ";" */
terminal COLON; /* ":" */
terminal COMMA; /* "," */

terminal POINT; /* "." */

terminal ASSIGNMENT; /* "=" */

terminal CHAR_CONST; /* char value: 'a', ... */ 
terminal BOOL_CONST; /* bool value: true/false*/
terminal Integer NUMBER; /* integer value: 0, ... */

terminal LEFT_ROUND_BRACKET, RIGHT_ROUND_BRACKET; /* "("")" */
terminal LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET; /* "[""]" */
terminal LEFT_CURLY_BRACKET, RIGHT_CURLY_BRACKET; /* "{""}" */

terminal INC;
terminal DEC;
terminal PLUS; /* "+" */
terminal MINUS; /* "-" */
terminal MULTIPLY; /* "*" */
terminal DIVIDE; /* "/" */
terminal MODUO; /* "%" */

terminal PRINT, RETURN;
terminal String IDENT;
terminal IF, ELSE;

terminal READ;
terminal GOTO, DO, WHILE;

terminal AND, OR;
terminal NEW;
terminal ENUM, RECORD;
terminal SUPER, THIS;

terminal BREAK, CONTINUE;
terminal EQUAL, NOT_EQUAL, LESS, GREATER, GREATER_EQUAL, LESS_EQUAL;



nonterminal ActualPars, ActualParamList;
nonterminal Matched, Unmatched;


/* NON terminals */
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program; /* Program = "program" ProgName (...) part, fetch program name and save to progName */
nonterminal AllDeclarationsList; /* this will collect all constants, (global) variables, classes and records declarations */

nonterminal ConstDecl; /* "const" (...) this will collect all ConstDecls */
nonterminal ConstDeclType; /* type of constant */
nonterminal ConstValue; /* value of constant */
nonterminal MoreSingleLineConstDeclarations; /* this will collect all constants between initial constant and ; `"const" Type ident "=" value` (. "," ident "=" value .) `";"` */

nonterminal VarDecl; /* this will collect all global variables */
nonterminal VarDeclType; /* type of global variables, this will be common type for all variables in the row */ 
nonterminal VarDeclList; /* this will collect all variable names, and divide them to not-last-one ant the last-one */
/* not-last-one (NotLastVarDecl) and last-one (LastVarDecl) nonterminals are differed because of error handling: if the error happened all tokens except "," and ";" should be consumed.
   NotLastVarDecl will cover consuming to the "," while the LastVarDecl will cover consuming to the ";"
 */
nonterminal NotLastVarDecl; /* this will collect all variable names until the last, it can be like varName or varName[] */
nonterminal LastVarDecl; /* this will collect the last variable name, it can be like varName or varName[]  */
nonterminal ArrayBrackets; /* this will represent [] declaration like int a[], and will contain the info about if the variable is array or not */

nonterminal RecordDecl; /* "record" recordName "{" (...) "}" */
nonterminal RecordVarDecl; /* this will represent variable declarations in record */

nonterminal ClassDecl; /* "class" className (.1.) (.2.) */
nonterminal OptionalExtend; /* "extends" superClassName, this is optional part in class declaration (.1.) */
nonterminal ClassBody; /* this will be the class body "{" (.2.) (.3.) "}", brackets are mandatory, and inner content is optional, and it is bellow */
nonterminal ClassFieldsVariables; /* class fields (.2.), this is basically VarDecl, but error handling is different: all tokens except ";" and "{" should be consumed  */
nonterminal ClassVarDecl; /* collect one declaration: type (.2.1.) ";", there we consume symbols */
nonterminal ClassVarDeclList; /* list of variable names bounded by ",", (.2.1.) in ClassVarDecl*/
nonterminal ClassSingleVarDecl; /* one variable name, it can be like varName or varName[] */
/* (.3.) is optional part of class, and it is like "{" (.3.1.) (.3.2.) "}" */
nonterminal ConstructorDecl; /* class constructor (.3.1.), method without type and with the same name as class. There we do not check this equallity. */
nonterminal ClassMethodDeclarations; /* class methods (.3.2.), no difference between regular methods */
nonterminal ConstructorVarDecl; /* local variables for constructor, there error handling is as same as VarDecl */
nonterminal ConstructorBody; /* constructor body contains any statement */

nonterminal MethodDeclList; /* list of all methods' declarations */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl; /* returnType methodName "(" (.4.) localVariables "{" methodBody "}" */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodTypeName; /* this will represent return type and methodName */
nonterminal MethodReturnType; /* this will represent all possible return types */
nonterminal MethodVarDecl; /* local variables for method, there error handling is as same as VarDecl */

nonterminal FormPars; /* this will say if the formal parameter list is empty or not (.4.) and match ")" if the formal parameters do not exists*/
nonterminal FormalParamList; /* this will represent the whole optional formal parameters list, and match ")" after the last formal parameter. */ 
/* error handling for formal parameters will be in FormalParamList: 
   all tokens except "," (when the mathcing of the formal parameters is continued) 
   and ")" (no more formal parameters) should be consumed 
   */
nonterminal FormalParameterDeclaration; /* one formal parameter name, it can be like parName or parName[] */

nonterminal StatementList; /* this will say if there is any statement */
nonterminal Statement; /* this will represent optionalLabel":" (.5.) or "{" (.6.) "}" */
/* (.6.) is repeated StatementList in inner block, here we do not worry about the scope, but it represents an inner scope */
nonterminal Label; /* this will represent label name */
nonterminal SingleStatement; /* this is collection of all simple statements (.5.) */
nonterminal DesignatorStatement; /* this will collect assignment, function calls, inc and dec statements */

nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator; /* this will represent variable, or className.someName (with arbitrary depth of indirection) or arrayName[expression]*/
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr; /* represent expressions, with possible +/- operators because of asociativiry */

nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term;
nonterminal TermList;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type; /* ident that represent the variable type. It can be int/bool/char or an arbitrary class name */
nonterminal FactorList;

nonterminal Addop; /* contains "+" and "-" */
nonterminal Mulop; /* contains "*", "/" and "%" */


/* Grammar */

Program ::= (Program) PROG ProgName:p AllDeclarationsList LEFT_CURLY_BRACKET MethodDeclList RIGHT_CURLY_BRACKET;

ProgName ::= (ProgName) IDENT:progName;

AllDeclarationsList ::= (VarDeclarations) AllDeclarationsList VarDecl
						|
						(ConstDeclarations) AllDeclarationsList ConstDecl
						|
						(ClassDeclarations) AllDeclarationsList ClassDecl
						|
						(RecordDeclarations) AllDeclarationsList RecordDecl
						|
						(NoDeclarations) /* epsilon */
						;

/* constants */

ConstDecl ::= (ConstDecl) CONST ConstDeclType IDENT:constName ASSIGNMENT ConstValue:constValue MoreSingleLineConstDeclarations SEMI;

ConstDeclType ::= (ConstDeclType) Type:constType;

ConstValue ::= (BooleanValue) BOOL_CONST:constValue
			   |
			   (IntegerValue) NUMBER:constValue
			   |
			   (CharValue) CHAR_CONST:constValue
			   ;

MoreSingleLineConstDeclarations ::= (MoreConstDeclarations) MoreSingleLineConstDeclarations COMMA IDENT:constName ASSIGNMENT ConstValue:constValue
									|
									(NoMoreConstDeclarations) /* epsilon */
									;

/* Type; usage: constants, variables, classes */
Type ::= (Type) IDENT:typeName;

/* global variables; constructor variables */

VarDecl ::= (VarDecl) VarDeclType VarDeclList;

VarDeclType ::= (VarDeclType) Type:varType;

VarDeclList ::= (VarDeclMultiple) NotLastVarDecl VarDeclList
				|
				(VarDeclLast) LastVarDecl
				;

NotLastVarDecl ::= (VarFromMultiplePart) IDENT:varName ArrayBrackets COMMA
   				   |
				   (ErrorInVarFromMultiplePart) error COMMA
				   ;

LastVarDecl ::= (VarFromLastPart) IDENT:varName ArrayBrackets SEMI
				|
				(ErrorInVarFromLastPart) error SEMI
				;

ArrayBrackets ::= (VariableIsArray) LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET
				  |
				  (VariableIsNotArray) /* epsilon */
				  ;

/* records */

RecordDecl ::= (RecordDecl) RECORD IDENT:recordName LEFT_CURLY_BRACKET RecordVarDecl RIGHT_CURLY_BRACKET;

RecordVarDecl ::= (RecordHasVariables) RecordVarDecl VarDecl
				  |
				  (RecordHasNotVariables) /* epsilon */
			      ;

/* classes */

ClassDecl ::= (ClassDecl) CLASS IDENT:className OptionalExtend ClassBody;

OptionalExtend ::= (ClassHasParent) EXTENDS Type:parentClassName
				   | 
 				   (ClassHasNoParent) /* epsilon */
				   | 
 				   (ErrorInExtendingClass) error /* no need for "{" here; everything will be consumed until the "{" in ClassDecl production */
 				   ;

ClassBody ::= (ClassBodyNoConstructorNoMethod) LEFT_CURLY_BRACKET ClassFieldsVariables RIGHT_CURLY_BRACKET
			  |
			  (ClassFullBody) LEFT_CURLY_BRACKET ClassFieldsVariables LEFT_CURLY_BRACKET ConstructorDecl ClassMethodDeclarations RIGHT_CURLY_BRACKET RIGHT_CURLY_BRACKET
			  ;

ClassFieldsVariables ::= (ClassFields) ClassFieldsVariables ClassVarDecl
						 |
						 (NoClassFields) /* epsilon */
						 ;

ClassVarDecl ::= (TypedListClassVarDecl) Type:varType ClassVarDeclList SEMI
				 |
				 (ErrorInClassVarDecl) error
    			 ;

ClassVarDeclList ::= (ClassVarDeclMultiple) ClassVarDeclList COMMA ClassSingleVarDecl 
				|
				(ClassVarDeclSingle) ClassSingleVarDecl
				;

ClassSingleVarDecl ::= (ClassSingleVarDecl) IDENT:varName ArrayBrackets;


ConstructorDecl ::= (ClassConstructor) IDENT:constructorName LEFT_ROUND_BRACKET RIGHT_ROUND_BRACKET ConstructorVarDecl LEFT_CURLY_BRACKET ConstructorBody RIGHT_CURLY_BRACKET
					|
					(NoClassConstructor) /* epsilon */
					; 

ConstructorVarDecl ::= (ConstructorHasVariables) ConstructorVarDecl VarDecl
					   |
					   (ConstructorHasNotVariables) /* epsilon */
					   ;

ConstructorBody ::= (EmptyConstructorBody) /* epsilon */
					; // Fill it with statement

ClassMethodDeclarations ::= (NoClassMethodDecl) /* epsilon */
							; // fill it with method



/* methods */

MethodDeclList ::= (NonEmptyMethodDeclList) MethodDeclList MethodDecl
				   |
				   (EmptyMethodDeclList) /* epsilon */
				   ;

MethodDecl ::= (CorrectMethodDecl) MethodTypeName LEFT_ROUND_BRACKET FormPars MethodVarDecl LEFT_CURLY_BRACKET StatementList RIGHT_CURLY_BRACKET;

MethodTypeName ::= (MethodTypeName) MethodReturnType IDENT:methName;

MethodReturnType ::= (ConcreteType) Type:retType
					 |
					 (VoidType) VOID
					 ;

MethodVarDecl ::= (MethodHasVariables) MethodVarDecl VarDecl
				  |
				  (MethodHasNotVariables) /* epsilon */
				  ;


FormPars ::= (FormalParameters) FormalParamList
			 |
			 (NoFormalParameters) RIGHT_ROUND_BRACKET
			 ;
			
FormalParamList ::= (MultipleFormalParameters) FormalParameterDeclaration COMMA FormalParamList
	 				|
					(SingleFormalParameter) FormalParameterDeclaration RIGHT_ROUND_BRACKET
	 				|
					(ErrorInOneFormalParameter) error COMMA FormalParamList
	 				|
					(ErrorInListOfFormalParameters) error RIGHT_ROUND_BRACKET
					;

FormalParameterDeclaration ::= (FormalParameterDeclaration) Type:parameterType IDENT:parameterName ArrayBrackets;

/* statements */

StatementList ::= (NonEmptyStement) StatementList Statement
				  |
				  (NoStatements) /* epsilon */
				  ;

Statement ::= (LabeledSingleStatementMatch) Label COLON SingleStatement
			  |
			  (SingleStatementMatch) SingleStatement
			  |
			  (StatementBlock) LEFT_CURLY_BRACKET StatementList RIGHT_CURLY_BRACKET 
			  ;

/* Label; usage: statement */
Label ::= (Label) IDENT:labelName;

SingleStatement ::= (StatementDesignator) DesignatorStatement;

DesignatorStatement ::= (DesignatorAssignOperation) Designator:dest ASSIGNMENT Expr:e SEMI
						|
						(ErrorInDesignatorAssignOperation) error SEMI:l
					    {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :}
						|
						(DesignatorFunctionCall) Designator:functionName LEFT_ROUND_BRACKET ActualPars RIGHT_ROUND_BRACKET SEMI
						;

Designator ::= (ClassFieldDesignator) Designator POINT IDENT:leftField
			   |
			   (ArrayDesignator) Designator LEFT_SQUARE_BRACKET Expr:arrayIndex RIGHT_SQUARE_BRACKET
			   |
			   (SimpleDesignator) IDENT:name
			   ;


Expr ::= (PositiveExpr) TermList:t
		 |
		 (NegativeExpr) MINUS TermList:t
		 ;						

TermList ::= (AddOpTermList) TermList Addop Term
			 |
			 (SingleTerm) Term:t
			 ;

Term ::= (Term) FactorList:t;

FactorList ::= (MulOpFactorList) FactorList:t Mulop Factor
			   |
			   (SingleFactor) Factor:t
			   ;

Factor ::= (Const) NUMBER
		|
		(Var) Designator:d
		|
		(FuncCall) Designator:func LEFT_ROUND_BRACKET ActualPars RIGHT_ROUND_BRACKET
		;


ActualPars ::= (Actuals) ActualParamList
			|
			(NoActuals) /* epsilon */
			;
			
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
				|
				(ActualParam) Expr
				;		


//Statement ::= (MatchedStmt) Matched
//			  |
//			  (UnmatchedStmt) Unmatched
// 			  ;

Unmatched ::= (IfStatement) IF Expr Statement
			  |
			  (UnmatchedIfElse) IF Expr Matched ELSE Unmatched
			  ;

Matched ::=   (PrintStmt) PRINT LEFT_ROUND_BRACKET Expr RIGHT_ROUND_BRACKET SEMI
			  |
			  (ReturnExpr) RETURN Expr:t SEMI
			  |
			  (ReturnNoExpr) RETURN SEMI
			  |
			  (MatchedStatement) IF Expr Matched ELSE Matched
              |
			  (ProcCall) Designator:func LEFT_ROUND_BRACKET ActualPars RIGHT_ROUND_BRACKET SEMI
			  ;				



		
	

Addop ::= (PlusOp) PLUS
		  |
		  (MinusOp) MINUS;

Mulop ::= (MultiplyOp) MULTIPLY
		  |
		  (DivideOp) DIVIDE
		  |
		  (ModuoOp) MODUO
		  ;

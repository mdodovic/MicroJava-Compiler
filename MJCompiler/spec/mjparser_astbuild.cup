
package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;

import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
	
	boolean errorDetected;
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
		errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}

init with{:
	errorDetected = false;

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

/* terminals */

terminal PROG; /* "program" */ 
terminal CONST; /* "const" */
terminal VOID; /* "void" */

terminal CLASS; /* "class" */
terminal EXTENDS; /* "extends" */
terminal NEW; /* "new" */
terminal RECORD; /* "record" */

terminal SEMI; /* ";" */
terminal COLON; /* ":" */
terminal COMMA; /* "," */

terminal POINT; /* "." */

terminal ASSIGNMENT; /* "=" */

terminal IF; /* "if" */
terminal ELSE; /* "else" */
terminal DO; /* "do" */
terminal WHILE; /* "while" */
terminal BREAK; /* "break" */
terminal CONTINUE; /* "continue" */
terminal RETURN; /* "return" */
terminal GOTO; /* "goto" */

terminal PRINT; /* "print" */
terminal READ; /* "read" */

terminal Character CHAR_CONST; /* char value: 'a', ... */ 
terminal Boolean BOOL_CONST; /* bool value: true/false */
terminal Integer NUMBER; /* integer value: 0, ... */
terminal String IDENT; /* string value: varName, ... */

terminal LEFT_ROUND_BRACKET, RIGHT_ROUND_BRACKET; /* "("")" */
terminal LEFT_SQUARE_BRACKET, RIGHT_SQUARE_BRACKET; /* "[""]" */
terminal LEFT_CURLY_BRACKET, RIGHT_CURLY_BRACKET; /* "{""}" */

terminal INC; /* "++" */
terminal DEC; /* "--" */
terminal PLUS; /* "+" */
terminal MINUS; /* "-" */
terminal MULTIPLY; /* "*" */
terminal DIVIDE; /* "/" */
terminal MODUO; /* "%" */

terminal AND; /* "&&" */
terminal OR; /* "||" */

terminal EQUAL; /* "==" */
terminal NOT_EQUAL; /* "!=" */
terminal LESS; /* "<" */
terminal GREATER; /* ">" */
terminal GREATER_EQUAL; /* ">=" */
terminal LESS_EQUAL; /* "<=" */

/* unused terminals */
terminal ENUM;


/* NON terminals */

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program; /* Program = "program" ProgName (...) part, fetch program name and save to progName */
nonterminal AllDeclarationsList AllDeclarationsList; /* this will collect all constants, (global) variables, classes and records declarations */

nonterminal ConstDecl ConstDecl; /* "const" (...) this will collect all ConstDecls */
nonterminal ConstDeclType ConstDeclType; /* type of constant */
nonterminal ConstValueAssignment ConstValueAssignment; /* assignment of constant: constName = constValue */
nonterminal MoreSingleLineConstDeclarations MoreSingleLineConstDeclarations; /* this will collect all constant assignments between initial constant */

nonterminal VarDecl VarDecl; /* this will collect all global variables */
nonterminal VarDeclType VarDeclType; /* type of global variables, this will be common type for all variables in the row */ 
nonterminal VarDeclList VarDeclList; /* this will collect all variable names, and divide them to not-last-one ant the last-one */
/* not-last-one (NotLastVarDecl) and last-one (LastVarDecl) nonterminals are differed because of error handling: if the error happened all tokens except "," and ";" should be consumed.
   NotLastVarDecl will cover consuming to the "," while the LastVarDecl will cover consuming to the ";"
 */
nonterminal NotLastVarDecl NotLastVarDecl; /* this will collect all variable names until the last, it can be like varName or varName[] */
nonterminal LastVarDecl LastVarDecl; /* this will collect the last variable name, it can be like varName or varName[]  */
nonterminal ArrayBrackets ArrayBrackets; /* this will represent [] declaration like int a[], and will contain the info about if the variable is array or not */

nonterminal RecordDecl RecordDecl; /* this is the representation of Record = recordDeclName "{" RecordVarDecl "}" */
nonterminal rs.etf.pp1.symboltable.concepts.Obj RecordDeclName; /* this will represent "record" recordName */
nonterminal RecordVarDecl RecordVarDecl; /* this will represent variable declarations in record */

nonterminal ClassDecl ClassDecl; /* "class" className (.1.) (.2.) */
nonterminal OptionalExtend OptionalExtend; /* "extends" superClassName, this is optional part in class declaration (.1.) */
nonterminal ClassBody ClassBody; /* this will be the class body "{" (.2.) (.3.) "}", brackets are mandatory, and inner content is optional, and it is bellow */
/* Because of the shift reduce conflicts class constructor and class methods needs to be in this production.
   There are 5 different variants: no body, only "{}", only "{" constructor "}", only "{" methods "}", both "{" constructor methods "}"  
   So (.3.) is divided on these parts for further explanations: "{" (.3.1.) (.3.2.) "}"
  */
nonterminal ClassFieldsVariables ClassFieldsVariables; /* class fields (.2.), this is basically VarDecl, but error handling is different: all tokens except ";" and "{" should be consumed  */
nonterminal ClassVarDecl ClassVarDecl; /* collect one declaration: type (.2.1.) ";", there we consume symbols */
nonterminal ClassVarDeclList ClassVarDeclList; /* list of variable names bounded by ",", (.2.1.) in ClassVarDecl*/
nonterminal ClassSingleVarDecl ClassSingleVarDecl; /* one variable name, it can be like varName or varName[] */
nonterminal ConstructorDecl ConstructorDecl; /* class constructor (.3.1.), method without type and with the same name as class. Here this constructor is default (without parameters) and has body as same as regular method. */ 
/* There we do not if the constructor name mathces the class name */
nonterminal ClassMethodDeclarations ClassMethodDeclarations; /* class methods (.3.2.), recursive list with concrete method declaration (MethodDecl) terminating */
nonterminal ConstructorVarDecl ConstructorVarDecl; /* local variables for constructor, there error handling is as same as VarDecl */

nonterminal MethodDeclList MethodDeclList; /* list of all methods' declarations */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl; /* returnType methodName "(" (.4.) localVariables "{" methodBody "}" */
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodTypeName; /* this will represent return type and methodName */
nonterminal rs.etf.pp1.symboltable.concepts.Struct MethodReturnType; /* this will represent all possible return types */
nonterminal MethodVarDecl MethodVarDecl; /* local variables for method, there error handling is as same as VarDecl */

nonterminal FormPars FormPars; /* this will say if the formal parameter list is empty or not (.4.) and match ")" if the formal parameters do not exists*/
nonterminal FormalParamList FormalParamList; /* this will represent the whole optional formal parameters list, and match ")" after the last formal parameter. */ 
/* error handling for formal parameters will be in FormalParamList: 
   all tokens except "," (when the mathcing of the formal parameters is continued) 
   and ")" (no more formal parameters) should be consumed 
   */
nonterminal FormalParameterDeclaration FormalParameterDeclaration; /* one formal parameter name, it can be like parName or parName[] */

nonterminal StatementList StatementList; /* this will say if there is any statement */
nonterminal Statement Statement; /* this will represent optionalLabel":" (.5.) or "{" (.6.) "}" */
/* (.6.) is repeated StatementList in inner block, here we do not worry about the scope, but it represents an inner scope */
nonterminal Label Label; /* this will represent label name */
nonterminal SingleStatement SingleStatement; /* this is collection of all simple statements (.5.) */
nonterminal DesignatorStatement DesignatorStatement; /* this will collect assignment, function calls, inc and dec statements */

nonterminal rs.etf.pp1.symboltable.concepts.Obj Designator; /* this will represent variable, or className.someName (with arbitrary depth of indirection) or arrayName[expression]*/
nonterminal rs.etf.pp1.symboltable.concepts.Struct Expr; /* represent expressions which optionally can start with "-" */
nonterminal rs.etf.pp1.symboltable.concepts.Struct TermList; /* represent list of terms with possible +/- operators because of associativity  */
nonterminal rs.etf.pp1.symboltable.concepts.Struct Term; /* represent single term which is the list of factors */
nonterminal rs.etf.pp1.symboltable.concepts.Struct FactorList; /* represent list of factors with possible mul/mod/div operators because of associativity */
nonterminal rs.etf.pp1.symboltable.concepts.Struct Factor; /* represent single factor that can be variable, functionCall, number, character, true/false, creation of an array (new int[expression]) and expression surrounded with "(" ")" */

nonterminal rs.etf.pp1.symboltable.concepts.Struct Type; /* ident that represent the variable type. It can be int/bool/char or an arbitrary class name */

nonterminal ActualPars ActualPars; /* this will say if there are any actual parameters in the function call */ 
nonterminal ActualParamList ActualParamList; /* this represents actual parameters in function call, that can by any expression */

nonterminal IfCondition IfCondition; /* this will represent if"(" condition ")" part because of error handling in condition: all tokens except ")" should be consumed */
nonterminal Condition Condition; /* this will represent list of conditionals separated with "||" (logically OR), conditionals between OR are matched separately because of the associativity */
nonterminal CondTerm CondTerm; /* this will represent list of conditionals separated with "&&" (logically AND), conditionals between AND are matched separately because of the associativity */
nonterminal CondFact CondFact; /* this will represent expression with bool logical value (we do not check it here) or two expressions related with some of the relational operators (Relop is defined bellow) */

nonterminal Relop Relop; /* contains "==", "!=", ">", ">=", "<" and "<=" */
nonterminal Addop Addop; /* contains "+" and "-" */
nonterminal Mulop Mulop; /* contains "*", "/" and "%" */

/* Dummy productions has just purpose to be first visited in Abstract Syntax Tree */
nonterminal DoWhileDummyStart DoWhileDummyStart; /* this will represent the beginning of the do-while construction */

/* precedences */

precedence left ELSE;

/* Grammar */

Program ::= (Program) PROG ProgName:p AllDeclarationsList:A1 LEFT_CURLY_BRACKET MethodDeclList:M2 RIGHT_CURLY_BRACKET {: RESULT=new Program(p, A1, M2); RESULT.setLine(pleft); :};

ProgName ::= (ProgName) IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

AllDeclarationsList ::= (VarDeclarations) AllDeclarationsList:A1 VarDecl:V2 {: RESULT=new VarDeclarations(A1, V2); RESULT.setLine(A1left); :}
						|
						(ConstDeclarations) AllDeclarationsList:A1 ConstDecl:C2 {: RESULT=new ConstDeclarations(A1, C2); RESULT.setLine(A1left); :}
						|
						(ClassDeclarations) AllDeclarationsList:A1 ClassDecl:C2 {: RESULT=new ClassDeclarations(A1, C2); RESULT.setLine(A1left); :}
						|
						(RecordDeclarations) AllDeclarationsList:A1 RecordDecl:R2 {: RESULT=new RecordDeclarations(A1, R2); RESULT.setLine(A1left); :}
						|
						(NoDeclarations) {: RESULT=new NoDeclarations(); :} /* epsilon */
						;

/* constants */

ConstDecl ::= (ConstDecl) CONST ConstDeclType:C1 ConstValueAssignment:C2 MoreSingleLineConstDeclarations:M3 SEMI {: RESULT=new ConstDecl(C1, C2, M3); RESULT.setLine(C1left); :};

ConstDeclType ::= (ConstDeclType) Type:constType {: RESULT=new ConstDeclType(constType); RESULT.setLine(constTypeleft); :};

ConstValueAssignment ::= (BooleanValue) IDENT:constName ASSIGNMENT BOOL_CONST:boolConstValue {: RESULT=new BooleanValue(constName, boolConstValue); RESULT.setLine(constNameleft); :}
			   			 |
					     (IntegerValue) IDENT:constName ASSIGNMENT NUMBER:numberConstValue {: RESULT=new IntegerValue(constName, numberConstValue); RESULT.setLine(constNameleft); :}
					     |
			   		 	 (CharValue) IDENT:constName ASSIGNMENT CHAR_CONST:charConstValue {: RESULT=new CharValue(constName, charConstValue); RESULT.setLine(constNameleft); :}
			   		 	 ;

MoreSingleLineConstDeclarations ::= (MoreConstDeclarations) MoreSingleLineConstDeclarations:M1 COMMA ConstValueAssignment:C2 {: RESULT=new MoreConstDeclarations(M1, C2); RESULT.setLine(M1left); :}
									|
									(NoMoreConstDeclarations) {: RESULT=new NoMoreConstDeclarations(); :} /* epsilon */
									;

/* Type; usage: constants, variables, classes */
Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};

/* global variables; constructor variables */

VarDecl ::= (VarDecl) VarDeclType:V1 VarDeclList:V2 {: RESULT=new VarDecl(V1, V2); RESULT.setLine(V1left); :};

VarDeclType ::= (VarDeclType) Type:varType {: RESULT=new VarDeclType(varType); RESULT.setLine(varTypeleft); :};

VarDeclList ::= (VarDeclMultiple) NotLastVarDecl:N1 VarDeclList:V2 {: RESULT=new VarDeclMultiple(N1, V2); RESULT.setLine(N1left); :}
				|
				(VarDeclLast) LastVarDecl:L1 {: RESULT=new VarDeclLast(L1); RESULT.setLine(L1left); :}
				;

NotLastVarDecl ::= (VarFromMultiplePart) IDENT:varName ArrayBrackets:A1 COMMA {: RESULT=new VarFromMultiplePart(varName, A1); RESULT.setLine(varNameleft); :}
   				   |
				   (ErrorInVarFromMultiplePart) error COMMA {: RESULT=new ErrorInVarFromMultiplePart(); :}
				   ;

LastVarDecl ::= (VarFromLastPart) IDENT:varName ArrayBrackets:A1 SEMI {: RESULT=new VarFromLastPart(varName, A1); RESULT.setLine(varNameleft); :}
				|
				(ErrorInVarFromLastPart) error SEMI {: RESULT=new ErrorInVarFromLastPart(); :}
				;

ArrayBrackets ::= (VariableIsArray) LEFT_SQUARE_BRACKET RIGHT_SQUARE_BRACKET {: RESULT=new VariableIsArray(); :}
				  |
				  (VariableIsNotArray) {: RESULT=new VariableIsNotArray(); :} /* epsilon */
				  ;

/* records */

RecordDecl ::= (RecordDecl) RecordDeclName:R1 LEFT_CURLY_BRACKET RecordVarDecl:R2 RIGHT_CURLY_BRACKET {: RESULT=new RecordDecl(R1, R2); RESULT.setLine(R1left); :};

RecordDeclName ::= (RecordDeclName) RECORD IDENT:recordName {: RESULT=new RecordDeclName(recordName); RESULT.setLine(recordNameleft); :};

RecordVarDecl ::= (RecordHasVariables) RecordVarDecl:R1 VarDecl:V2 {: RESULT=new RecordHasVariables(R1, V2); RESULT.setLine(R1left); :}
				  |
				  (RecordHasNotVariables) {: RESULT=new RecordHasNotVariables(); :} /* epsilon */
			      ;

/* classes */

ClassDecl ::= (ClassDecl) CLASS IDENT:className OptionalExtend:O1 ClassBody:C2 {: RESULT=new ClassDecl(className, O1, C2); RESULT.setLine(classNameleft); :};

OptionalExtend ::= (ClassHasParent) EXTENDS Type:parentClassName {: RESULT=new ClassHasParent(parentClassName); RESULT.setLine(parentClassNameleft); :}
				   | 
 				   (ClassHasNoParent) {: RESULT=new ClassHasNoParent(); :} /* epsilon */
				   | 
 				   (ErrorInExtendingClass) error {: RESULT=new ErrorInExtendingClass(); :} /* no need for "{" here; everything will be consumed until the "{" in ClassDecl production */
 				   ;

ClassBody ::= (ClassBodyNoConstructorNoMethod) LEFT_CURLY_BRACKET ClassFieldsVariables:C1 RIGHT_CURLY_BRACKET {: RESULT=new ClassBodyNoConstructorNoMethod(C1); RESULT.setLine(C1left); :}
			  |
			  (ClassBodyBrackets) LEFT_CURLY_BRACKET ClassFieldsVariables:C1 
			  							LEFT_CURLY_BRACKET 
										RIGHT_CURLY_BRACKET 
							 	  RIGHT_CURLY_BRACKET {: RESULT=new ClassBodyBrackets(C1); RESULT.setLine(C1left); :}
			  |
			  (ClassBodyConstructor) LEFT_CURLY_BRACKET ClassFieldsVariables:C1 
			  							LEFT_CURLY_BRACKET 
									  		ConstructorDecl:C2
										RIGHT_CURLY_BRACKET 
							 		 RIGHT_CURLY_BRACKET {: RESULT=new ClassBodyConstructor(C1, C2); RESULT.setLine(C1left); :}
			  |
			  (ClassBodyMethods) LEFT_CURLY_BRACKET ClassFieldsVariables:C1 
			  						LEFT_CURLY_BRACKET 
									  ClassMethodDeclarations:C2 
									RIGHT_CURLY_BRACKET 
								RIGHT_CURLY_BRACKET {: RESULT=new ClassBodyMethods(C1, C2); RESULT.setLine(C1left); :}
			  |
			  (ClassBodyFull) LEFT_CURLY_BRACKET ClassFieldsVariables:C1 
			  					LEFT_CURLY_BRACKET 
									ConstructorDecl:C2
									ClassMethodDeclarations:C3  
								RIGHT_CURLY_BRACKET 
							  RIGHT_CURLY_BRACKET {: RESULT=new ClassBodyFull(C1, C2, C3); RESULT.setLine(C1left); :}
			  ;

ClassFieldsVariables ::= (ClassFields) ClassFieldsVariables:C1 ClassVarDecl:C2 {: RESULT=new ClassFields(C1, C2); RESULT.setLine(C1left); :}
						 |
						 (NoClassFields) {: RESULT=new NoClassFields(); :} /* epsilon */
						 ;

ClassVarDecl ::= (TypedListClassVarDecl) Type:varType ClassVarDeclList:C1 SEMI {: RESULT=new TypedListClassVarDecl(varType, C1); RESULT.setLine(varTypeleft); :}
				 |
				 (ErrorInClassVarDecl) error {: RESULT=new ErrorInClassVarDecl(); :}
    			 ;

ClassVarDeclList ::= (ClassVarDeclMultiple) ClassVarDeclList:C1 COMMA ClassSingleVarDecl:C2 {: RESULT=new ClassVarDeclMultiple(C1, C2); RESULT.setLine(C1left); :} 
				|
				(ClassVarDeclSingle) ClassSingleVarDecl:C1 {: RESULT=new ClassVarDeclSingle(C1); RESULT.setLine(C1left); :}
				;

ClassSingleVarDecl ::= (ClassSingleVarDecl) IDENT:varName ArrayBrackets:A1 {: RESULT=new ClassSingleVarDecl(varName, A1); RESULT.setLine(varNameleft); :};


ConstructorDecl ::= (ClassConstructor) IDENT:constructorName LEFT_ROUND_BRACKET RIGHT_ROUND_BRACKET ConstructorVarDecl:C1 LEFT_CURLY_BRACKET StatementList:S2 RIGHT_CURLY_BRACKET {: RESULT=new ClassConstructor(constructorName, C1, S2); RESULT.setLine(constructorNameleft); :};

ConstructorVarDecl ::= (ConstructorHasVariables) ConstructorVarDecl:C1 VarDecl:V2 {: RESULT=new ConstructorHasVariables(C1, V2); RESULT.setLine(C1left); :}
					   |
					   (ConstructorHasNotVariables) {: RESULT=new ConstructorHasNotVariables(); :} /* epsilon */
					   ;

ClassMethodDeclarations ::= (MultipleClassMethods) ClassMethodDeclarations:C1 MethodDecl:M2 {: RESULT=new MultipleClassMethods(C1, M2); RESULT.setLine(C1left); :}
				  			|
				   			(SingleClassMethod) MethodDecl:M1 {: RESULT=new SingleClassMethod(M1); RESULT.setLine(M1left); :}
				   			;


/* methods */

MethodDeclList ::= (NonEmptyMethodDeclList) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new NonEmptyMethodDeclList(M1, M2); RESULT.setLine(M1left); :}
				   |
				   (EmptyMethodDeclList) {: RESULT=new EmptyMethodDeclList(); :} /* epsilon */
				   ;

MethodDecl ::= (CorrectMethodDecl) MethodTypeName:M1 LEFT_ROUND_BRACKET FormPars:F2 MethodVarDecl:M3 LEFT_CURLY_BRACKET StatementList:S4 RIGHT_CURLY_BRACKET {: RESULT=new CorrectMethodDecl(M1, F2, M3, S4); RESULT.setLine(M1left); :};

MethodTypeName ::= (MethodTypeName) MethodReturnType:M1 IDENT:methName {: RESULT=new MethodTypeName(M1, methName); RESULT.setLine(M1left); :};

MethodReturnType ::= (ConcreteType) Type:retType {: RESULT=new ConcreteType(retType); RESULT.setLine(retTypeleft); :}
					 |
					 (VoidType) VOID {: RESULT=new VoidType(); :}
					 ;

MethodVarDecl ::= (MethodHasVariables) MethodVarDecl:M1 VarDecl:V2 {: RESULT=new MethodHasVariables(M1, V2); RESULT.setLine(M1left); :}
				  |
				  (MethodHasNotVariables) {: RESULT=new MethodHasNotVariables(); :} /* epsilon */
				  ;


FormPars ::= (FormalParameters) FormalParamList:F1 {: RESULT=new FormalParameters(F1); RESULT.setLine(F1left); :}
			 |
			 (NoFormalParameters) RIGHT_ROUND_BRACKET {: RESULT=new NoFormalParameters(); :}
			 ;
			
FormalParamList ::= (MultipleFormalParameters) FormalParameterDeclaration:F1 COMMA FormalParamList:F2 {: RESULT=new MultipleFormalParameters(F1, F2); RESULT.setLine(F1left); :}
	 				|
					(SingleFormalParameter) FormalParameterDeclaration:F1 RIGHT_ROUND_BRACKET {: RESULT=new SingleFormalParameter(F1); RESULT.setLine(F1left); :}
	 				|
					(ErrorInOneFormalParameter) error COMMA FormalParamList:F1 {: RESULT=new ErrorInOneFormalParameter(F1); RESULT.setLine(F1left); :}
	 				|
					(ErrorInListOfFormalParameters) error RIGHT_ROUND_BRACKET {: RESULT=new ErrorInListOfFormalParameters(); :}
					;

FormalParameterDeclaration ::= (FormalParameterDeclaration) Type:parameterType IDENT:parameterName ArrayBrackets:A1 {: RESULT=new FormalParameterDeclaration(parameterType, parameterName, A1); RESULT.setLine(parameterTypeleft); :};

/* statements */

StatementList ::= (NonEmptyStement) StatementList:S1 Statement:S2 {: RESULT=new NonEmptyStement(S1, S2); RESULT.setLine(S1left); :}
				  |
				  (NoStatements) {: RESULT=new NoStatements(); :} /* epsilon */
				  ;

Statement ::= (LabeledSingleStatementMatch) Label:L1 COLON SingleStatement:S2 {: RESULT=new LabeledSingleStatementMatch(L1, S2); RESULT.setLine(L1left); :}
			  |
			  (SingleStatementMatch) SingleStatement:S1 {: RESULT=new SingleStatementMatch(S1); RESULT.setLine(S1left); :}
			  |
			  (StatementBlock) LEFT_CURLY_BRACKET StatementList:S1 RIGHT_CURLY_BRACKET {: RESULT=new StatementBlock(S1); RESULT.setLine(S1left); :} 
			  ;

/* Label; usage: statement */
Label ::= (Label) IDENT:labelName {: RESULT=new Label(labelName); RESULT.setLine(labelNameleft); :};

SingleStatement ::= (StatementDesignator) DesignatorStatement:D1 {: RESULT=new StatementDesignator(D1); RESULT.setLine(D1left); :}
					|
					(StatementIf) IfCondition:I1 Statement:S2 {: RESULT=new StatementIf(I1, S2); RESULT.setLine(I1left); :}
					|
					(StatementIfElse) IfCondition:I1 Statement:S2 ELSE Statement:S3 {: RESULT=new StatementIfElse(I1, S2, S3); RESULT.setLine(I1left); :}
					|
					(StatementDoWhile) DO DoWhileDummyStart:D1 Statement:S2 WHILE LEFT_ROUND_BRACKET Condition:C3 RIGHT_ROUND_BRACKET SEMI {: RESULT=new StatementDoWhile(D1, S2, C3); RESULT.setLine(D1left); :}
					|
					(StatementBreak) BREAK SEMI {: RESULT=new StatementBreak(); :}
					|
					(StatementContinue) CONTINUE SEMI {: RESULT=new StatementContinue(); :}
					|
					(StatementReturnEmpty) RETURN SEMI {: RESULT=new StatementReturnEmpty(); :}
					|
					(StetementReturnExpression) RETURN Expr:t SEMI {: RESULT=new StetementReturnExpression(t); RESULT.setLine(tleft); :}
					|
					(StatementPrintNoWidth) PRINT LEFT_ROUND_BRACKET Expr:E1 RIGHT_ROUND_BRACKET SEMI {: RESULT=new StatementPrintNoWidth(E1); RESULT.setLine(E1left); :}
					|
					(StatementPrintWithWidth) PRINT LEFT_ROUND_BRACKET Expr:E1 COMMA NUMBER:N2 RIGHT_ROUND_BRACKET SEMI {: RESULT=new StatementPrintWithWidth(E1, N2); RESULT.setLine(E1left); :}
					|
					(StatementRead) READ LEFT_ROUND_BRACKET Designator:D1 RIGHT_ROUND_BRACKET SEMI {: RESULT=new StatementRead(D1); RESULT.setLine(D1left); :}
					|
					(StatementGoTo) GOTO Label:L1 SEMI {: RESULT=new StatementGoTo(L1); RESULT.setLine(L1left); :}
					;

DoWhileDummyStart ::= {: RESULT=new DoWhileDummyStartDerived1(); :} /* epsilon */;

IfCondition ::= (IfPart) IF LEFT_ROUND_BRACKET Condition:C1 RIGHT_ROUND_BRACKET {: RESULT=new IfPart(C1); RESULT.setLine(C1left); :}
				|
				(ErrorInCondition) IF LEFT_ROUND_BRACKET error:l {: parser.report_error("Izvrsen oporavak do ) u liniji " + lleft, null); :} RIGHT_ROUND_BRACKET {: RESULT=new ErrorInCondition(); :}
				;

/* if-else conditions */

Condition ::= (OrOpCondTermList) Condition:C1 OR CondTerm:C2 {: RESULT=new OrOpCondTermList(C1, C2); RESULT.setLine(C1left); :}
			  |
			  (SingleCondTerm) CondTerm:t {: RESULT=new SingleCondTerm(t); RESULT.setLine(tleft); :}
			  ;

CondTerm ::= (AndOpCondFact) CondTerm:C1 AND CondFact:C2 {: RESULT=new AndOpCondFact(C1, C2); RESULT.setLine(C1left); :}
			 |
 			 (SingleCondFact) CondFact:t {: RESULT=new SingleCondFact(t); RESULT.setLine(tleft); :}
			 ;

CondFact ::= (RelOpExpr) Expr:eleft Relop:R1 Expr:eright {: RESULT=new RelOpExpr(eleft, R1, eright); RESULT.setLine(eleftleft); :}
			 |
			 (SingleExpr) Expr:e {: RESULT=new SingleExpr(e); RESULT.setLine(eleft); :}
			 ;


/* Designators */

DesignatorStatement ::= (DesignatorAssignOperation) Designator:dest ASSIGNMENT Expr:e SEMI {: RESULT=new DesignatorAssignOperation(dest, e); RESULT.setLine(destleft); :}
						|
						(ErrorInDesignatorAssignOperation) error SEMI:l
					    {: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null); :} {: RESULT=new ErrorInDesignatorAssignOperation(); :}
						|
						(DesignatorFunctionCall) Designator:functionName LEFT_ROUND_BRACKET ActualPars:A1 RIGHT_ROUND_BRACKET SEMI {: RESULT=new DesignatorFunctionCall(functionName, A1); RESULT.setLine(functionNameleft); :}
						|
						(DesignatorPostIncrement) Designator:variableName INC SEMI {: RESULT=new DesignatorPostIncrement(variableName); RESULT.setLine(variableNameleft); :}
						|
						(DesignatorPostDecrement) Designator:variableName DEC SEMI {: RESULT=new DesignatorPostDecrement(variableName); RESULT.setLine(variableNameleft); :}
						;

Designator ::= (ClassFieldDesignator) Designator:D1 POINT IDENT:leftField {: RESULT=new ClassFieldDesignator(D1, leftField); RESULT.setLine(D1left); :}
			   |
			   (ArrayDesignator) Designator:D1 LEFT_SQUARE_BRACKET Expr:arrayIndex RIGHT_SQUARE_BRACKET {: RESULT=new ArrayDesignator(D1, arrayIndex); RESULT.setLine(D1left); :}
			   |
			   (SimpleDesignator) IDENT:name {: RESULT=new SimpleDesignator(name); RESULT.setLine(nameleft); :}
			   ;

/* Expressions */

Expr ::= (PositiveExpr) TermList:t {: RESULT=new PositiveExpr(t); RESULT.setLine(tleft); :}
		 |
		 (NegativeExpr) MINUS TermList:t {: RESULT=new NegativeExpr(t); RESULT.setLine(tleft); :}
		 ;						

TermList ::= (AddOpTermList) TermList:T1 Addop:A2 Term:T3 {: RESULT=new AddOpTermList(T1, A2, T3); RESULT.setLine(T1left); :}
			 |
			 (SingleTerm) Term:T1 {: RESULT=new SingleTerm(T1); RESULT.setLine(T1left); :}
			 ;

Term ::= (Term) FactorList:F1 {: RESULT=new Term(F1); RESULT.setLine(F1left); :};

FactorList ::= (MulOpFactorList) FactorList:F1 Mulop:M2 Factor:F3 {: RESULT=new MulOpFactorList(F1, M2, F3); RESULT.setLine(F1left); :}
			   |
			   (SingleFactor) Factor:F1 {: RESULT=new SingleFactor(F1); RESULT.setLine(F1left); :}
			   ;

Factor ::= (FactorVariable) Designator:variableName {: RESULT=new FactorVariable(variableName); RESULT.setLine(variableNameleft); :}
		   |
		   (FactorFunctionCall) Designator:functionName LEFT_ROUND_BRACKET ActualPars:A1 RIGHT_ROUND_BRACKET {: RESULT=new FactorFunctionCall(functionName, A1); RESULT.setLine(functionNameleft); :}
		   |
		   (FactorNumConst) NUMBER:constValue {: RESULT=new FactorNumConst(constValue); RESULT.setLine(constValueleft); :}
		   |
		   (FactorCharConst) CHAR_CONST:constValue {: RESULT=new FactorCharConst(constValue); RESULT.setLine(constValueleft); :}
		   |
		   (FactorBoolConst) BOOL_CONST:constValue {: RESULT=new FactorBoolConst(constValue); RESULT.setLine(constValueleft); :}
		   |
		   (FactorClassNewOperator) NEW Type:className {: RESULT=new FactorClassNewOperator(className); RESULT.setLine(classNameleft); :}
		   |
		   (FactorArrayNewOperator) NEW Type:arrayName LEFT_SQUARE_BRACKET Expr:arrayIndex RIGHT_SQUARE_BRACKET {: RESULT=new FactorArrayNewOperator(arrayName, arrayIndex); RESULT.setLine(arrayNameleft); :}
		   |
		   (FactorBracketExpression) LEFT_ROUND_BRACKET Expr:innerExpression RIGHT_ROUND_BRACKET {: RESULT=new FactorBracketExpression(innerExpression); RESULT.setLine(innerExpressionleft); :}
		   ;


ActualPars ::= (Actuals) ActualParamList:A1 {: RESULT=new Actuals(A1); RESULT.setLine(A1left); :}
			   |
			   (NoActuals) {: RESULT=new NoActuals(); :} /* epsilon */
			   ;
			
ActualParamList ::= (ActualParams) ActualParamList:A1 COMMA Expr:E2 {: RESULT=new ActualParams(A1, E2); RESULT.setLine(A1left); :}
				    |
				    (ActualParam) Expr:E1 {: RESULT=new ActualParam(E1); RESULT.setLine(E1left); :}
				    ;		

		
/* Operations */	

Relop ::= (EqualOp) EQUAL {: RESULT=new EqualOp(); :}
		  | 
		  (NotEqualOp) NOT_EQUAL {: RESULT=new NotEqualOp(); :}
		  | 
		  (LessOp) LESS {: RESULT=new LessOp(); :}
		  | 
		  (GreaterOp) GREATER {: RESULT=new GreaterOp(); :}
		  | 
		  (GreaterEqualOp) GREATER_EQUAL {: RESULT=new GreaterEqualOp(); :}
		  | 
		  (LessEqualOp) LESS_EQUAL {: RESULT=new LessEqualOp(); :}
		  ;

Addop ::= (PlusOp) PLUS {: RESULT=new PlusOp(); :}
		  |
		  (MinusOp) MINUS {: RESULT=new MinusOp(); :};

Mulop ::= (MultiplyOp) MULTIPLY {: RESULT=new MultiplyOp(); :}
		  |
		  (DivideOp) DIVIDE {: RESULT=new DivideOp(); :}
		  |
		  (ModuoOp) MODUO {: RESULT=new ModuoOp(); :}
		  ;
